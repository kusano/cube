<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta property="og:title" content="2x2x2不完全一面手順集">
    <title>2x2x2不完全一面手順集</title>
    <link rel="stylesheet" href="../bulma1.min.css">
  </head>
  <body>
    <section class="section">
      <div class="container content">
        <h1>2x2x2不完全一面手順集</h1>
        <p>
          <a href="../">ルービックキューブ関連</a> &gt; 2x2x2不完全一面手順集
        </p>
        <p>
          覚えておくと良さそうな手順をまとめる。
        </p>
        <p>
          「このスクランブルに良い手順が無いかな？」というときは、「<a href="../222_1face/">2x2x2 Cube 1 Face Solver</a>」をご活用ください。
        </p>
        <table class="table">
          <thead>
            <tr>
              <th style="width: 128px">画像</th>
              <th style="width: 8em">手順</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><canvas class="cube" data-algorithm="R U R'"></canvas></td>
              <td><b>R U R'</b></td>
              <td><b>U' F' U F</b> としたくなるが、3手で揃う。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F R U' R'"></canvas></td>
              <td><b>F R U' R'</b></td>
              <td>すでに揃っているD面の配置が換わることに注意。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R U R' F'"></canvas></td>
              <td><b>R U R' F</b></td>
              <td><b>F' L' U L</b> でも良いが、この手順だと右手主体になる。D面の配置が換わることに注意。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F R2 F'"></canvas></td>
              <td><b>F R2 F'</b></td>
              <td><b>B U2 B'</b> のB面の動きをF面に置き換え。隣接交換のバーをDBに置きたいとき用。私は <b>B U2 B'</b> とは別の手順と認識しているけど、上手い人はこれが同じに見えたりするのだろうか？</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F R' F'"></canvas></td>
              <td><b>F R' F'</b></td>
              <td><b>B U' B'</b> のB面の動きをF面に置き換え。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R2 U' R2"></canvas></td>
              <td><b>R2 U' R2</b></td>
              <td>残り1個のD面色がU面を向いているとき、入れる場所とのズレが90度なら3手。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R2 U2 R"></canvas></td>
              <td><b>R2 U2 R</b></td>
              <td>2個ずつペアになっているが、そのままでは合わない形。ペアを一度崩す。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R U' R"></canvas></td>
              <td><b>R U' R</b></td>
              <td><b>F'</b> で離れている2個が揃うが、揃っている2個が崩れてしまう。それなら <b>F'</b> が <b>U'</b> になるようにU面に上げて……と考えれば良いのだろうか。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F R2"></canvas></td>
              <td><b>F R2</b></td>
              <td>各面にD面色が高々1ピースのバラバラで、2手で揃えられるのはこの形しか無いはず。これが見えるようになりたい。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F U' R'"></canvas></td>
              <td><b>F U' R'</b></td>
              <td>すでに揃っている2個を一度崩す。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="U F U' R'"></canvas></td>
              <td><b>U F U' R'</b></td>
              <td><b>U</b>＋上の手順。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R2 U F2 R'"></canvas></td>
              <td><b>R2 U F2 R'</b></td>
              <td>対角の2個が揃っていて、残りが向き違いでD面にある面倒そうな状態。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R2 U F' U' R'"></canvas></td>
              <td><b>R2 U F' U' R'</b></td>
              <td>これが最短なので、他の色を見るべき。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F' U' R"></canvas></td>
              <td><b>F' U' R</b></td>
              <td>対角の2個が揃っている状態はたいてい手数が掛かるが、これは3手。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R2 F R2"></canvas></td>
              <td><b>R2 F R2</b></td>
              <td>これも3手。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F R2 U' R2"></canvas></td>
              <td><b>F R2 U' R2</b></td>
              <td><b>F U2 F2 U F2</b> だと5手だが4手で揃う。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="F' R2 U' R2"></canvas></td>
              <td><b>F' R2 U' R2</b></td>
              <td>同上。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="R2 F2 U2 R'"></canvas></td>
              <td><b>R2 F2 U2 R'</b></td>
              <td>4手だが、バラバラの状態を経由するので難しい。</td>
            </tr>
            <tr>
              <td><canvas class="cube" data-algorithm="U R2 F2 U2 R"></canvas></td>
              <td><b>U R2 F2 U2 R</b></td>
              <td>上3個と似ているが、これは5手掛かる。</td>
            </tr>
          </tbody>
        </table>
        <hr>
        <address class="mb-6 has-text-right">
          <a href="https://twitter.com/kusano_k">@kusano_k</a>
        </address>
      </div>
    </section>
    <script>
/*
       0  1
       2  3
      -----
 4  5| 8  9|12 13|16 17|
 6  7|10 11|14 15|18 19|
      -----
      20 21
      22 23
*/
class Cube {
  static moveTable = {
    "F": [ 0,  1,  7,  5,   4, 20,  6, 21,  10,  8, 11,  9,   2, 13,  3, 15,  16, 17, 18, 19,  14, 12, 22, 23],
    "B": [13, 15,  2,  3,   1,  5,  0,  7,   8,  9, 10, 11,  12, 23, 14, 22,  18, 16, 19, 17,  20, 21,  4,  6],
    "R": [ 0,  9,  2, 11,   4,  5,  6,  7,   8, 21, 10, 23,  14, 12, 15, 13,   3, 17,  1, 19,  20, 18, 22, 16],
    "L": [19,  1, 17,  3,   6,  4,  7,  5,   0,  9,  2, 11,  12, 13, 14, 15,  16, 22, 18, 20,   8, 21, 10, 23],
    "U": [ 2,  0,  3,  1,   8,  9,  6,  7,  12, 13, 10, 11,  16, 17, 14, 15,   4,  5, 18, 19,  20, 21, 22, 23],
    "D": [ 0,  1,  2,  3,   4,  5, 18, 19,   8,  9,  6,  7,  12, 13, 10, 11,  16, 17, 14, 15,  22, 20, 23, 21],
  };

  static {
    const T = Cube.moveTable;

    function composite(X, Y) {
      const Z = Array(24);
      for (let i=0; i<24; i++) {
        Z[i] = X[Y[i]];
      }
      return Z;
    }

    for (const m of ["F", "B", "R", "L", "U", "D"]) {
      T[m+"2"] = composite(T[m], T[m]);
      T[m+"'"] = composite(T[m+"2"], T[m]);
    }
  }

  move(m) {
    const tmp = [...this.faces];
    for (let i=0; i<24; i++) {
      this.faces[i] = tmp[Cube.moveTable[m][i]];
    }
  }
};

let color = 0;
for (let canvas of document.querySelectorAll(".cube")) {
  const cube = new Cube();
  cube.faces = ("...................."+["RRRR", "FFFF", "BBBB", "LLLL"][color++%4]).split("");

  for (const move of canvas.dataset.algorithm.split(" ").reverse()) {
    let rev = "";
    if (move.length==1) {
      rev = move[0]+"'";
    } else if (move[1]=="2") {
      rev = move;
    } else {
      rev = move[0];
    }
    cube.move(rev);
  }

  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio;
  canvas.width = 92*dpr;
  canvas.height = 92*dpr;
  ctx.scale(dpr, dpr);
  canvas.style.width = `${92}px`;
  canvas.style.height = `${92}px`;

  function rotate(x, y, z) {
    const th1 = 0.6;
    const x2 = x*Math.cos(th1)-z*Math.sin(th1);
    const y2 = y;
    const z2 = x*Math.sin(th1)+z*Math.cos(th1);

    const th2 = 0.3;
    const x3 = x2;
    const y3 = y2*Math.cos(th2)-z2*Math.sin(th2);
    const z3 = y2*Math.sin(th2)+z2*Math.cos(th2);

    const w = 28;
    const s = 0.2;
    const x4 = x3*(z3*s/2+1)*w+48;
    const y4 = -y3*(z3*s/2+1)*w+48;

    return [x4, y4];
  }

  const FP = [
    [[-1,  1, -1], [ 1,  1, -1], [ 1,  1,  1], [-1,  1,  1]],
    [[-1,  1, -1], [-1,  1,  1], [-1, -1,  1], [-1, -1, -1]],
    [[-1,  1,  1], [ 1,  1,  1], [ 1, -1,  1], [-1, -1,  1]],
    [[ 1,  1,  1], [ 1,  1, -1], [ 1, -1, -1], [ 1, -1,  1]],
    [[ 1,  1, -1], [-1,  1, -1], [-1, -1, -1], [ 1, -1, -1]],
    [[-1, -1,  1], [ 1, -1,  1], [ 1, -1, -1], [-1, -1, -1]],
  ];

  // B, L, D, F, R, Uの順に描画。
  const I = [];
  for (let f of [16, 4, 20, 8, 12, 0]) {
    for (let i=0; i<4; i++) {
      I.push(f+i);
    }
  }

  for (let i of I) {
    const fp = FP[i/4|0];
    const fx = i%4%2;
    const fy = i%4/2|0;

    ctx.beginPath();
    ctx.moveTo(...rotate(
      (fp[1][0]-fp[0][0])*fx/2+(fp[3][0]-fp[0][0])*fy/2+fp[0][0],
      (fp[1][1]-fp[0][1])*fx/2+(fp[3][1]-fp[0][1])*fy/2+fp[0][1],
      (fp[1][2]-fp[0][2])*fx/2+(fp[3][2]-fp[0][2])*fy/2+fp[0][2]));
    ctx.lineTo(...rotate(
      (fp[1][0]-fp[0][0])*(fx+1)/2+(fp[3][0]-fp[0][0])*fy/2+fp[0][0],
      (fp[1][1]-fp[0][1])*(fx+1)/2+(fp[3][1]-fp[0][1])*fy/2+fp[0][1],
      (fp[1][2]-fp[0][2])*(fx+1)/2+(fp[3][2]-fp[0][2])*fy/2+fp[0][2]));
    ctx.lineTo(...rotate(
      (fp[1][0]-fp[0][0])*(fx+1)/2+(fp[3][0]-fp[0][0])*(fy+1)/2+fp[0][0],
      (fp[1][1]-fp[0][1])*(fx+1)/2+(fp[3][1]-fp[0][1])*(fy+1)/2+fp[0][1],
      (fp[1][2]-fp[0][2])*(fx+1)/2+(fp[3][2]-fp[0][2])*(fy+1)/2+fp[0][2]));
    ctx.lineTo(...rotate(
      (fp[1][0]-fp[0][0])*fx/2+(fp[3][0]-fp[0][0])*(fy+1)/2+fp[0][0],
      (fp[1][1]-fp[0][1])*fx/2+(fp[3][1]-fp[0][1])*(fy+1)/2+fp[0][1],
      (fp[1][2]-fp[0][2])*fx/2+(fp[3][2]-fp[0][2])*(fy+1)/2+fp[0][2]));
    ctx.closePath();

    if (cube.faces[i]==".") {
      ctx.fillStyle = "rgb(192 192 192 / 60%)";
    } else {
      const rgb = {
        "F": "8 250 8",
        "B": "8 8 250",
        "R": "250 8 8",
        "L": "250 128 8",
        "U": "255 255 255",
        "D": "250 250 0",
      }[cube.faces[i]];
      ctx.fillStyle = `rgb(${rgb} / 90%)`;
    }
    ctx.fill();
    ctx.lineWidth = .5;
    ctx.stroke();
  }
}
    </script>
  </body>
</html>
